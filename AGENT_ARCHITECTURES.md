# Архитектуры агентов

В проекте реализованы **две архитектуры** агентов:

## 1. Supervisor-based (по умолчанию)

**Файл:** `orchestration/supervisor.py`

### Особенности:
- ✅ Один LLM (Claude через OpenRouter)
- ✅ LangGraph для оркестрации
- ✅ Автоматический выбор инструментов
- ✅ Параллельное выполнение инструментов
- ✅ Feedback loop для итеративного улучшения

### Поток:
```
User Input → Supervisor (Claude) → Tool Selection → ToolNode → Results → Supervisor → Response
```

### Инструменты:
- **GcodeAnalyzer** - анализ G-code файлов
- **RAGEngine** - поиск в базе знаний
- **VisionPipeline** - анализ изображений
- **HardwareInterface** - управление принтером

### Преимущества:
- Быстрая обработка
- Эффективное использование токенов
- Автоматический выбор нужных инструментов
- Поддержка сложных сценариев

---

## 2. MultiModel (опциональная)

**Файл:** `agents/multi_model_agent.py`

### Архитектура:
- ✅ 4 роли с разными задачами
- ✅ **Только Консультант общается с пользователем**
- ✅ Остальные агенты работают внутренне
- ✅ Структурированные ответы (dataclass'ы)
- ✅ Мета-агент для анализа логов (`agents/meta_refinement_agent.py`)

### Pipeline:
```
1. Аналитик → анализирует запрос, разбивает на подзадачи, формирует ключевые слова (внутренний)
2. RAG → ищет в базе знаний на основе ключевых слов от Аналитика
3. Консультант → готовит технический ответ для пользователя (единственный, кто общается с пользователем)
4. Редактор → создает упрощенную версию (внутренняя валидация)
5. Проверяющий → оценивает качество в JSON (внутренняя валидация)
```

### Роли:

#### 1️⃣ Аналитик (внутренний)
**Обязанности:**
- Уточняет цель пользователя, формулирует высокоуровневую «Цель запроса»
- Разбивает задачу на 3–10 конкретных подзадач
- Формирует список ключевых слов и фраз для поиска по базе знаний (RAG) и логам G-code
- Определяет, какие фрагменты G-code, параметры принтера, материалы, прошивки критически важны
- Если запрос вне домена — честно отмечает это

**Вывод:** Структурированный JSON с целью, подзадачами, ключевыми словами, критическими данными

#### 2️⃣ Консультант (единственный, кто общается с пользователем)
**Обязанности:**
- Опираясь на запрос пользователя, вывод Аналитика и RAG-контекст, дает подробное инженерное объяснение
- Приоритизирует данный контекст (база знаний, реальные фрагменты G-code) над общими догадками
- Явно указывает, если информации не хватает: что именно неизвестно, какие данные/файлы стоит запросить
- Не придумывает значения параметров и не описывает поведение оборудования, если это не следует из контекста

**Формат ответа:**
- «Краткий вывод» (2–4 предложения)
- «Технический разбор» — структурированное объяснение по пунктам
- «Рекомендуемые действия» — нумерованный список шагов
- «Что уточнить» — список недостающих данных (если есть)

#### 3️⃣ Редактор (внутренний, для валидации)
**Обязанности:**
- Переписывает ответ Консультанта простым языком для новичка, без потери важных ограничений и рисков
- Упрощает формулировки, разбивает объяснения на логичные блоки
- Сохраняет все ключевые технические моменты, указания по безопасности и ограничения
- Объясняет термины в скобках при первом упоминании

**Формат ответа:**
- Блок «Что происходит»
- Блок «Что делать по шагам»
- Блок «На что обратить внимание (риски, ограничения)»

**Важно:** Редактор не добавляет новых фактов и не меняет технический смысл.

#### 4️⃣ Проверяющий (внутренний, для валидации)
**Обязанности:**
- Выставляет оценки correctness, completeness, clarity по шкале 1–10
- Кратко перечисляет сильные стороны ответа, проблемы и возможные галлюцинации/опасные советы

**Формат вывода:** JSON-подобный объект
```json
{
  "correctness": <1-10>,
  "completeness": <1-10>,
  "clarity": <1-10>,
  "comments": {
    "strengths": ["..."],
    "issues": ["..."],
    "risksOrHallucinations": ["..."]
  }
}
```

### Преимущества:
- Более структурированные ответы
- Строгий контроль качества (QA Checker)
- Детальная обработка запросов
- Четкое разделение ролей (только Консультант общается с пользователем)
- Внутренняя валидация через Редактора и Проверяющего

### Недостатки:
- Больше вызовов LLM (больше токенов)
- Медленнее обработка
- Выше стоимость

### Мета-агент для улучшения промптов

**Файл:** `agents/meta_refinement_agent.py`

Отдельный класс `MetaRefinementAgent` для анализа логов диалогов и предложения улучшений промптов.

**Функции:**
- Анализ выборки логов (запросы, ответы агентов, оценки QA)
- Обнаружение паттернов проблем (галлюцинации, пропуск шагов, игнорирование RAG-контекста)
- Диагностика по ролям (на каком этапе возникает проблема)
- Предложение точечных улучшений промптов для каждой роли

**Использование:**
```python
from agents.meta_refinement_agent import MetaRefinementAgent, LogEntry

meta_agent = MetaRefinementAgent()
logs = [LogEntry(user_query="...", consultant_output="...", qa_output={...})]
suggestions = await meta_agent.analyze_logs(logs)
```

---

## Переключение между архитектурами

### Через .env:
```bash
# Supervisor-based (по умолчанию)
USE_MULTI_MODEL_AGENT=False

# MultiModel
USE_MULTI_MODEL_AGENT=True
```

### Программно:
```python
from agent import Agent

# Supervisor-based
agent = Agent(use_multi_model=False)

# MultiModel
agent = Agent(use_multi_model=True)
```

---

## Когда использовать какую архитектуру?

### Supervisor-based (рекомендуется):
- ✅ Быстрые ответы
- ✅ Экономия токенов
- ✅ Автоматический выбор инструментов
- ✅ Сложные сценарии с несколькими инструментами

### MultiModel:
- ✅ Нужна упрощенная версия для новичков
- ✅ Требуется контроль качества ответов
- ✅ Детальная обработка сложных вопросов
- ✅ Образовательные цели

---

## Примеры использования

### Supervisor-based:
```python
from agent import Agent

agent = Agent()  # По умолчанию Supervisor
response = await agent.run("Почему мой первый слой не прилипает?", session_id=1, db=db)
```

### MultiModel:
```python
from agent import Agent

agent = Agent(use_multi_model=True)
response = await agent.run("Почему мой первый слой не прилипает?", session_id=1, db=db)
# Ответ включает только ответ Консультанта в структурированном формате:
# - Краткий вывод
# - Технический разбор
# - Рекомендуемые действия
# - Что уточнить
# 
# Редактор и Проверяющий работают внутренне для валидации
```

### Прямое использование MultiModelAgent:
```python
from agents.multi_model_agent import MultiModelAgent

agent = MultiModelAgent()
response = await agent.run("Почему мой первый слой не прилипает?", session_id=1, db=db)
```

