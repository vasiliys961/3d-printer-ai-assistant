# Архитектура приложения

## Обзор

Приложение построено по многослойной архитектуре с использованием мультиагентной системы на базе LangGraph.

## Слои архитектуры

### 1. User Interface Layer

**Компоненты:**
- **Telegram Bot** (`ui/telegram_bot.py`) - Асинхронный бот для взаимодействия через Telegram
- **Streamlit Dashboard** (`ui/streamlit_dashboard.py`) - Web-интерфейс для мониторинга и управления
- **REST API** (`api/main.py`) - RESTful API для интеграций с внешними системами

**Особенности:**
- Все интерфейсы используют единый Orchestration Layer
- Поддержка загрузки файлов (G-code, изображения)
- Real-time обновления статуса

### 2. Orchestration Layer (LangGraph)

**Компоненты:**
- **Supervisor** (`orchestration/supervisor.py`) - Claude-based агент для принятия решений
- **Router** (`orchestration/router.py`) - Маршрутизация запросов к нужным агентам
- **Executor** (`orchestration/executor.py`) - Выполнение инструментов агентов
- **Graph** (`orchestration/graph.py`) - LangGraph граф оркестрации

**Поток данных:**
```
User Request → Router → Agent → Executor → Tool → Results → Supervisor → Response
```

**Состояние (GraphState):**
- `messages` - История сообщений
- `context` - Контекст диалога
- `session_state` - Состояние сессии
- `tool_results` - Результаты работы инструментов
- `current_agent` - Текущий агент
- `next_agent` - Следующий агент

### 3. Tool/Agent Layer

#### 3.1 Code Interpreter (`agents/code_interpreter/`)

**Функции:**
- **Parser** - Парсинг G-code файлов (Regex + AST)
- **Validator** - Валидация параметров (температура, скорость, поток)
- **Generator** - Генерация последовательностей команд

**Инструменты:**
- `analyze_gcode` - Анализ G-code файла
- `validate_gcode` - Валидация на безопасность
- `generate_start_sequence` - Генерация стартовой последовательности
- `generate_end_sequence` - Генерация завершающей последовательности

#### 3.2 RAG Engine (`agents/rag_engine/`)

**Компоненты:**
- **Embedder** - Генерация embeddings (Sentence Transformers)
- **Chunker** - Разбиение документов на чанки (Parent docs strategy)
- **Reranker** - Re-ranking результатов (BM25 + semantic)

**Хранилище:**
- ChromaDB для векторных поисков

**Инструменты:**
- `search` - Поиск по базе знаний
- `add_knowledge` - Добавление знаний в базу

#### 3.3 Vision Pipeline (`agents/vision/`)

**Компоненты:**
- **YOLODetector** - Обнаружение объектов (YOLOv8)
- **ClaudeVision** - Детальный анализ сложных случаев

**Функции:**
- Обнаружение дефектов печати
- Классификация дефектов
- Оценка качества печати

**Инструменты:**
- `analyze_image` - Полный анализ изображения
- `detect_defects` - Обнаружение дефектов

#### 3.4 Hardware Interface (`agents/hardware/`)

**Поддержка:**
- **Klipper/Moonraker API** - Современные прошивки
- **OctoPrint API** - Legacy поддержка

**Функции:**
- Управление температурой
- Управление печатью (старт, стоп, пауза)
- Получение статуса принтера
- Управление осями

**Инструменты:**
- `get_status` - Статус принтера
- `get_temperature` - Текущие температуры
- `set_temperature` - Установка температуры
- `start_print` / `stop_print` / `pause_print` / `resume_print` - Управление печатью
- `home_axes` - Домой оси

### 4. Data Persistence Layer

#### 4.1 PostgreSQL (`data/postgres/`)

**Модели:**
- `User` - Пользователи системы
- `Dialog` - Диалоги с пользователями
- `Print` - Записи о печати
- `PrintImage` - Изображения печати

**Использование:**
- Хранение структурированных данных
- История диалогов
- Логирование печатей

#### 4.2 ChromaDB (`data/chroma_db.py`)

**Использование:**
- Векторное хранилище для RAG
- Embeddings документов
- Семантический поиск

#### 4.3 Redis (`data/redis_cache.py`)

**Использование:**
- Кэширование результатов поиска
- Кэширование выводов моделей
- Временное хранилище

#### 4.4 File Storage (`data/storage.py`)

**Поддержка:**
- LocalFS (локальное хранилище)
- S3 (облачное хранилище)

**Хранение:**
- G-code файлы
- Изображения печати
- Логи

## Поток обработки запроса

```
1. User Interface получает запрос
   ↓
2. Запрос передается в Orchestration Layer
   ↓
3. Router анализирует запрос и определяет нужного агента
   ↓
4. Executor вызывает соответствующий инструмент
   ↓
5. Tool выполняет задачу (может использовать Data Layer)
   ↓
6. Результаты возвращаются в GraphState
   ↓
7. Supervisor анализирует результаты
   ↓
8. Если нужно - переход к другому агенту (п.3)
   ↓
9. Генерация финального ответа через Claude
   ↓
10. Ответ возвращается пользователю
```

## Масштабируемость

- **Горизонтальное масштабирование**: Каждый слой может быть развернут отдельно
- **Асинхронность**: Все операции I/O асинхронные
- **Кэширование**: Redis для снижения нагрузки
- **Векторный поиск**: ChromaDB для быстрого поиска

## Безопасность

- Валидация G-code перед выполнением
- Проверка безопасных диапазонов параметров
- Изоляция пользовательских данных
- API ключи для внешних сервисов

## Расширяемость

- Легко добавить новых агентов в Tool Layer
- Простое добавление новых инструментов
- Модульная архитектура
- Поддержка плагинов через LangGraph

